"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π
"""
import logging
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, LabeledPrice, PreCheckoutQuery, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime
import uuid
import hashlib
from urllib import parse
from urllib.parse import urlparse
import decimal
import json

from src.config import (
    TARIFF_SMALL_PRICE_RUB as TARIFF_SMALL_PRICE,
    TARIFF_SMALL_PRICE_STARS,
    TARIFF_SMALL_READINGS,
    TARIFF_SMALL_DURATION,
    TARIFF_MEDIUM_PRICE_RUB as TARIFF_MEDIUM_PRICE,
    TARIFF_MEDIUM_PRICE_STARS,
    TARIFF_MEDIUM_READINGS,
    TARIFF_MEDIUM_DURATION,
    TARIFF_UNLIMITED_PRICE_RUB as TARIFF_UNLIMITED_PRICE,
    TARIFF_UNLIMITED_PRICE_STARS,
    TARIFF_UNLIMITED_DURATION,
    ROBOKASSA_LOGIN,
    ROBOKASSA_PASSWORD1
)
from src.database.models import User, Payment
from src.database.database import get_user, update_user_readings

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞
logger = logging.getLogger(__name__)

router = Router()

class PaymentStates(StatesGroup):
    waiting_for_payment = State()

def calculate_signature(*args) -> str:
    """Create signature MD5."""
    return hashlib.md5(':'.join(str(arg) for arg in args).encode()).hexdigest()

def parse_response(request: str) -> dict:
    """
    :param request: Link.
    :return: Dictionary.
    """
    params = {}
    for item in urlparse(request).query.split('&'):
        key, value = item.split('=')
        params[key] = value
    return params

def check_signature_result(
    order_number: int,  # invoice number
    received_sum: decimal,  # cost of goods, RU
    received_signature: str,  # SignatureValue
    password: str  # Merchant password
) -> bool:
    signature = calculate_signature(received_sum, order_number, password)
    if signature.lower() == received_signature.lower():
        return True
    return False

def generate_payment_link(
    merchant_login: str,  # Merchant login
    merchant_password_1: str,  # Merchant password
    cost: decimal,  # Cost of goods, RU
    number: int,  # Invoice number
    description: str,  # Description of the purchase
    is_test = 0,
    robokassa_payment_url = 'https://auth.robokassa.ru/Merchant/Index.aspx',
) -> str:
    """URL for redirection of the customer to the service."""
    signature = calculate_signature(
        merchant_login,
        cost,
        number,
        merchant_password_1
    )

    data = {
        'MerchantLogin': merchant_login,
        'OutSum': cost,
        'InvId': number,
        'Description': description,
        'SignatureValue': signature,
    }
    
    if is_test != 0:
        data['IsTest'] = is_test
        
    return f'{robokassa_payment_url}?{parse.urlencode(data)}'

def result_payment(merchant_password_2: str, request: str) -> str:
    """Verification of notification (ResultURL).
    :param request: HTTP parameters.
    """
    param_request = parse_response(request)
    cost = param_request['OutSum']
    number = param_request['InvId']
    signature = param_request['SignatureValue']

    if check_signature_result(number, cost, signature, merchant_password_2):
        return f'OK{param_request["InvId"]}'
    return "bad sign"

def check_success_payment(merchant_password_1: str, request: str) -> str:
    """Verification of operation parameters ("cashier check") in SuccessURL script.
    :param request: HTTP parameters
    """
    param_request = parse_response(request)
    cost = param_request['OutSum']
    number = param_request['InvId']
    signature = param_request['SignatureValue']

    if check_signature_result(number, cost, signature, merchant_password_1):
        return "Thank you for using our service"
    return "bad sign"

@router.message(F.text == "üí´ –ö—É–ø–∏—Ç—å —Ä–∞—Å–∫–ª–∞–¥—ã")
async def handle_buy_subscription(message: Message, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫—É–ø–∫–∏ —Ä–∞—Å–∫–ª–∞–¥–æ–≤"""
    logger.info("====================================")
    logger.info("============ –í–ï–†–°–ò–Ø: 5  ============")
    logger.info("====================================")
    
    user = await get_user(message.from_user.id, session)
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.id} –∑–∞–ø—Ä–æ—Å–∏–ª –ø–æ–∫—É–ø–∫—É —Ä–∞—Å–∫–ª–∞–¥–æ–≤")
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üîÆ –ú–∞–ª—ã–π (3 —Ä–∞—Å–∫–ª–∞–¥–∞)", callback_data="buy_small"),
                InlineKeyboardButton(text="‚ú® –°—Ä–µ–¥–Ω–∏–π (10 —Ä–∞—Å–∫–ª–∞–¥–æ–≤)", callback_data="buy_medium")
            ],
            [
                InlineKeyboardButton(text="üåü –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π", callback_data="buy_unlimited")
            ]
        ]
    )
    
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ:\n\n"
        "üîÆ –ú–∞–ª—ã–π - 3 —Ä–∞—Å–∫–ª–∞–¥–∞\n"
        f"üí∞ {TARIFF_SMALL_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_SMALL_PRICE_STARS}‚≠êÔ∏è\n\n"
        "‚ú® –°—Ä–µ–¥–Ω–∏–π - 10 —Ä–∞—Å–∫–ª–∞–¥–æ–≤\n"
        f"üí∞ {TARIFF_MEDIUM_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_MEDIUM_PRICE_STARS}‚≠êÔ∏è\n\n"
        "üåü –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π\n"
        f"üí∞ {TARIFF_UNLIMITED_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_UNLIMITED_PRICE_STARS}‚≠êÔ∏è",
        reply_markup=keyboard
    )

@router.callback_query(F.data.startswith("buy_"))
async def process_buy(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ç–∞—Ä–∏—Ñ–∞"""
    tariff_type = callback.data.split("_")[1]
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–∞—Ä–∏—Ñ–∞
    tariff_params = {
        "small": {
            "price": TARIFF_SMALL_PRICE,
            "price_stars": TARIFF_SMALL_PRICE_STARS,
            "readings": TARIFF_SMALL_READINGS,
            "duration": TARIFF_SMALL_DURATION,
            "name": "–ú–∞–ª—ã–π"
        },
        "medium": {
            "price": TARIFF_MEDIUM_PRICE,
            "price_stars": TARIFF_MEDIUM_PRICE_STARS,
            "readings": TARIFF_MEDIUM_READINGS,
            "duration": TARIFF_MEDIUM_DURATION,
            "name": "–°—Ä–µ–¥–Ω–∏–π"
        },
        "unlimited": {
            "price": TARIFF_UNLIMITED_PRICE,
            "price_stars": TARIFF_UNLIMITED_PRICE_STARS,
            "readings": -1,  # –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ
            "duration": TARIFF_UNLIMITED_DURATION,
            "name": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π"
        }
    }
    
    if tariff_type not in tariff_params:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∞—Ä–∏—Ñ", show_alert=True)
        return
    
    selected_tariff = tariff_params[tariff_type]
    payment_id = str(uuid.uuid4())
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(
        payment_id=payment_id,
        tariff=tariff_type,
        price_rub=selected_tariff["price"],
        price_stars=selected_tariff["price_stars"],
        readings=selected_tariff["readings"],
        duration=selected_tariff["duration"]
    )
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –≤—ã–±–æ—Ä–æ–º —Å–ø–æ—Å–æ–±–∞ –æ–ø–ª–∞—Ç—ã
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text=f"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å {selected_tariff['price']}‚ÇΩ",
                    callback_data=f"pay_robokassa_{payment_id}"
                )
            ],
            [
                InlineKeyboardButton(
                    text=f"‚≠êÔ∏è –û–ø–ª–∞—Ç–∏—Ç—å {selected_tariff['price_stars']} –∑–≤–µ–∑–¥",
                    callback_data=f"pay_stars_{payment_id}"
                )
            ],
            [
                InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_tariffs")
            ]
        ]
    )
    
    await callback.message.edit_text(
        f"–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ç–∞—Ä–∏—Ñ '{selected_tariff['name']}'\n\n"
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—Å–∫–ª–∞–¥–æ–≤: {selected_tariff['readings'] if selected_tariff['readings'] != -1 else '–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ'}\n"
        f"–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: {selected_tariff['duration']} –¥–Ω–µ–π\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:",
        reply_markup=keyboard
    )

@router.callback_query(F.data.startswith("pay_robokassa_"))
async def process_robokassa_payment(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ Robokassa"""
    data = await state.get_data()
    payment_id = data.get("payment_id")
    price_rub = data.get("price_rub")
    readings = data.get("readings")
    
    try:
        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –ø–ª–∞—Ç–µ–∂–µ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        user = await get_user(callback.from_user.id, session)
        new_payment = Payment(
            user_id=user.id,
            amount=int(price_rub),  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º decimal –≤ int
            currency="RUB",
            status="PENDING",
            payment_id=payment_id,
            readings_count=readings,
            duration_days=data.get("duration"),
            created_at=datetime.utcnow()
        )
        
        session.add(new_payment)
        await session.commit()
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è Robokassa –∏–∑ UUID
        numeric_inv_id = int(hashlib.md5(payment_id.encode()).hexdigest()[:7], 16) % 10000000
        logger.info(f"–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω UUID {payment_id} –≤ —á–∏—Å–ª–æ–≤–æ–π ID {numeric_inv_id}")
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ Robokassa
        payment_link = generate_payment_link(
            merchant_login=ROBOKASSA_LOGIN,
            merchant_password_1=ROBOKASSA_PASSWORD1,
            cost=price_rub,
            number=numeric_inv_id,
            description=f"–û–ø–ª–∞—Ç–∞ —Ç–∞—Ä–∏—Ñ–∞ {data.get('tariff')}",
            is_test=0
        )
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –¥–ª—è –æ–ø–ª–∞—Ç—ã
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å",
                        url=payment_link
                    )
                ],
                [
                    InlineKeyboardButton(
                        text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É",
                        callback_data=f"check_payment_{payment_id}"
                    )
                ],
                [
                    InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_tariffs")
                ]
            ]
        )
        
        await callback.message.edit_text(
            "–î–ª—è –æ–ø–ª–∞—Ç—ã –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ. –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É'.\n\n"
            f"–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ: {price_rub}‚ÇΩ",
            reply_markup=keyboard
        )
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞: {e}")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
        await state.clear()

@router.callback_query(F.data.startswith("pay_stars_"))
async def process_stars_payment(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–ø–ª–∞—Ç—ã –∑–≤–µ–∑–¥–∞–º–∏"""
    data = await state.get_data()
    price_stars = data.get("price_stars")
    readings = data.get("readings")
    
    await callback.message.answer_invoice(
        title=f"–¢–∞—Ä–∏—Ñ '{data.get('tariff')}'",
        description=f"–ü–æ–∫—É–ø–∫–∞ {readings if readings != -1 else '–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞'} —Ä–∞—Å–∫–ª–∞–¥–æ–≤",
        payload=data.get("payment_id"),
        provider_token="",  # –î–ª—è Stars –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç—ã–º
        currency="XTR",
        prices=[LabeledPrice(label="XTR", amount=price_stars)],
        start_parameter=data.get("payment_id")
    )

@router.pre_checkout_query()
async def process_pre_checkout(pre_checkout_query: PreCheckoutQuery):
    """–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞"""
    await pre_checkout_query.answer(ok=True)

@router.message(F.successful_payment)
async def process_successful_payment(message: Message, state: FSMContext, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞"""
    payment_data = await state.get_data()
    readings = payment_data.get("readings")
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    user = await get_user(message.from_user.id, session)
    
    if user:
        # –ï—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ –µ—Å—Ç—å —Ä–∞—Å–∫–ª–∞–¥—ã, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ
        current_readings = user.readings_left if user.readings_left != -1 else 0
        new_readings = -1 if readings == -1 or current_readings == -1 else current_readings + readings
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—Å–∫–ª–∞–¥–æ–≤
        await update_user_readings(user.id, new_readings, session)
        
        await message.answer(
            f"üéâ –°–ø–∞—Å–∏–±–æ –∑–∞ –æ–ø–ª–∞—Ç—É! –í–∞–º –¥–æ—Å—Ç—É–ø–Ω–æ "
            f"{'–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ' if new_readings == -1 else str(new_readings)} —Ä–∞—Å–∫–ª–∞–¥–æ–≤."
        )
    else:
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
    
    await state.clear()

@router.callback_query(F.data.startswith("check_payment_"))
async def check_payment_status(callback: CallbackQuery, session: AsyncSession):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞"""
    payment_id = callback.data.split("_")[2]
    
    # –ù–∞—Ö–æ–¥–∏–º –ø–ª–∞—Ç–µ–∂ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    payment = await session.execute(
        select(Payment).where(Payment.payment_id == payment_id)
    )
    payment = payment.scalar_one_or_none()
    
    if not payment:
        await callback.answer("–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return
    
    if payment.status == "COMPLETED":
        # –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω
        user = await get_user(callback.from_user.id, session)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —Ä–∞—Å–∫–ª–∞–¥–æ–≤
        if payment.readings_count == -1:  # –±–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π —Ç–∞—Ä–∏—Ñ
            await update_user_readings(user.id, -1, session)
        else:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ä–∞—Å–∫–ª–∞–¥–æ–≤
            current_readings = user.readings_left if hasattr(user, 'readings_left') else 0
            if hasattr(user, 'readings_remaining') and not hasattr(user, 'readings_left'):
                current_readings = user.readings_remaining
                
            if current_readings == -1:
                new_readings = -1
            else:
                new_readings = current_readings + payment.readings_count
                
            await update_user_readings(user.id, new_readings, session)
        
        await callback.message.edit_text(
            "‚úÖ –û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!\n\n"
            f"–í–∞–º –¥–æ—Å—Ç—É–ø–Ω–æ {'–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ' if payment.readings_count == -1 else str(payment.readings_count)} —Ä–∞—Å–∫–ª–∞–¥–æ–≤.",
            reply_markup=InlineKeyboardMarkup(
                inline_keyboard=[
                    [InlineKeyboardButton(text="üîÆ –°–¥–µ–ª–∞—Ç—å —Ä–∞—Å–∫–ª–∞–¥", callback_data="make_reading")]
                ]
            )
        )
    else:
        # –ü–ª–∞—Ç–µ–∂ –µ—â–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω –∏–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω
        await callback.message.edit_text(
            "‚è≥ –í–∞—à –ø–ª–∞—Ç–µ–∂ –µ—â–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –∏–ª–∏ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω.\n\n"
            "–ï—Å–ª–∏ –≤—ã —É–∂–µ –ø—Ä–æ–∏–∑–≤–µ–ª–∏ –æ–ø–ª–∞—Ç—É, –Ω–æ –≤–∏–¥–∏—Ç–µ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ. "
            "–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –¥–æ 5 –º–∏–Ω—É—Ç.\n\n"
            "–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –≤—ã–±–æ—Ä—É —Ç–∞—Ä–∏—Ñ–æ–≤.",
            reply_markup=InlineKeyboardMarkup(
                inline_keyboard=[
                    [InlineKeyboardButton(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", callback_data=f"check_payment_{payment_id}")],
                    [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Ç–∞—Ä–∏—Ñ–∞–º", callback_data="back_to_tariffs")]
                ]
            )
        )

@router.callback_query(F.data == "back_to_tariffs")
async def back_to_tariffs(callback: CallbackQuery, state: FSMContext):
    """–í–æ–∑–≤—Ä–∞—Ç –∫ –≤—ã–±–æ—Ä—É —Ç–∞—Ä–∏—Ñ–æ–≤"""
    await state.clear()
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üîÆ –ú–∞–ª—ã–π (3 —Ä–∞—Å–∫–ª–∞–¥–∞)", callback_data="buy_small"),
                InlineKeyboardButton(text="‚ú® –°—Ä–µ–¥–Ω–∏–π (10 —Ä–∞—Å–∫–ª–∞–¥–æ–≤)", callback_data="buy_medium")
            ],
            [
                InlineKeyboardButton(text="üåü –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π", callback_data="buy_unlimited")
            ]
        ]
    )
    
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ:\n\n"
        "üîÆ –ú–∞–ª—ã–π - 3 —Ä–∞—Å–∫–ª–∞–¥–∞\n"
        f"üí∞ {TARIFF_SMALL_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_SMALL_PRICE_STARS}‚≠êÔ∏è\n\n"
        "‚ú® –°—Ä–µ–¥–Ω–∏–π - 10 —Ä–∞—Å–∫–ª–∞–¥–æ–≤\n"
        f"üí∞ {TARIFF_MEDIUM_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_MEDIUM_PRICE_STARS}‚≠êÔ∏è\n\n"
        "üåü –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π\n"
        f"üí∞ {TARIFF_UNLIMITED_PRICE}‚ÇΩ –∏–ª–∏ {TARIFF_UNLIMITED_PRICE_STARS}‚≠êÔ∏è",
        reply_markup=keyboard
    )